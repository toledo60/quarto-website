{
  "hash": "e77a10aff0a010866416ff222b9e3f0c",
  "result": {
    "markdown": "---\ntoc: true\n---\n\n\n\n\n\n# R Basics\n\nThis lab consists of learning fundamental concepts in R\n\n## Variables\n\nA variable provides us with named objects that our programs can manipulate. A valid variable name consists of letters, numbers and the dot or underline characters. It is important to note variable names are case sensitive. That is, `var1` and `Var1` are different variables. Below are appropriate variable names in R\n\n| Valid Variable Name | Reason                                                 |\n|------------------------|-----------------------------------------------|\n| variable_name       | Contains letters and underscore                        |\n| long.variable_name  | Contains letters, dot, and underscore                  |\n| var                 | Contains letters                                       |\n| var1                | Contains letters and numbers                           |\n| long.variable_name2 | Contains letters, numbers, dot and underscore          |\n| var1_name.1         | Contains letters, numbers, dot and underscore          |\n| .var_name           | Can start with period, contains letters and underscore |\n\nThis is a good starting point for valid variable names. Next we demonstrate a few examples where variable names are invalid.\n\n| Invalid Variable Names | Reason                                                                     |\n|-------------------|-----------------------------------------------------|\n| 2var                   | Starts with a number                                                       |\n| \\_varname              | Starts with underscore                                                     |\n| .2var_name             | While starting with a (.) dot is valid, it can not be followed by a number |\n\nNow that we have an idea of how to name variables, lets discuss variable assignments. Variables can be assigned values using leftward `(<-)`, rightward `(->)` and equal `(=)` operators. However, we will only stick with the leftward and equal assignment operators.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvar_name1 <- 10\nvar2 = 20\nvar.name3 <- 30\nvar_name_4 = 40\n```\n:::\n\n\n## Vectors\n\nThe easiest method to create any type of vector in R is using `c()` (as in concatenate). We primarily focus on two types of vectors; *numeric* and *character*\n\n### Numeric vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_vec <- c(0,1,2,3,4)\ntypeof(num_vec)\nclass(num_vec)\n```\n:::\n\n\nUsing `c()` is not the only way to generate a vector, we can also generate the above vector using `seq()` as follows\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from=0,to=4)\n```\n:::\n\n\nAnother approach to generate the same sequence can be done using `0:4`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n0:4\n```\n:::\n\n\nor more generally `a:b`, where `a` is the starting number and `b` is the last number in the sequence\n\nWe can apply arithmetic operations to our numerical vector `num_vec`, such as addition, subtraction, multiplication, division, and exponentiation. These operations will be applied to each element in the vector *(element-wise)*.\n\n| Operator | Description                       |\n|----------|-----------------------------------|\n| \\+       | Addition                          |\n| \\-       | Subtraction                       |\n| \\*       | Multiplication                    |\n| /        | Division                          |\n| \\^       | Exponent                          |\n| %%       | Modulus (Remainder from division) |\n| %/%      | Integer Division                  |\n\nArithmetic operations applied to numeric vectors follow PEMDAS order of operations, demonstrated in the following example\n\n*Subtract 1 from each element*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(num_vec-1)\n```\n:::\n\n\n*Subtract 1 from each element, then square them*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(num_vec-1)^2\n```\n:::\n\n\n*Subtract 1 from each element, square them, then double each element*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n 2*(num_vec - 1)^2\n```\n:::\n\n\n*Subtract 1 from each element, square them, double them, then add 1 to each element*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2*(num_vec - 1)^2 + 1\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npemdas_vec <- 2*(num_vec - 1)^2 + 1\npemdas_vec\n```\n:::\n\n\nGenerating an odd sequence from 1 to 9, we can use `c()` or `seq()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1,3,5,7,9)\nseq(from =1,to=10,by=2)\n```\n:::\n\n\nNote if you know the ordering of the arguments of a function it is not necessary to specify them. For example, it is optional to write `from` and `to` arguments in the `seq()` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from = 1,to = 10)\nseq(1,10)\n```\n:::\n\n\n### Character vectors\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchr_vec <- c('A','B',\"C\")\ntypeof(chr_vec)\nclass(chr_vec)\n```\n:::\n\n\n## Manipulating vectors\n\nThere are multiple ways to access or replace values in vectors. The most common approach is through \"indexing\". It is important to know in \\verb|R| starts with index 1.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbig_vec <- 1:100\nbig_vec[1]\nbig_vec[10] # extract the 10th element in your vector\n```\n:::\n\n\nFor accessing elements in a vector we can think \n`vector[indices you want to extract]` the way we extract certain elements can be through some condition, that is `vector[condtion]`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbig_vec[ c(1,5,10) ]\nbig_vec[ 1:10 ] # what are the first 10 elements ?\n```\n:::\n\n\n\nUsing `c()` we can concatenate elements from one vector into another vector. For example, we can add the elements from `pemdas_vec` into the existing vector  `num_vec`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(num_vec,pemdas_vec)\n```\n:::\n\n\nAlternatively, we can add the elements from `num_vec` into the existing vector `pemdas_vec`\n\n::: {.cell}\n\n```{.r .cell-code}\nc(pemdas_vec,num_vec)\n```\n:::\n\n\nYou will notice the order in which we concatenate the elements from the vectors does matter\n\n\n::: {.cell}\n\n```{.r .cell-code}\nchr_vec\nchr_vec[1] <- 'a'\nchr_vec\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnum_vec\nnum_vec[3] <- 10\nnum_vec\nnum_vec[ c(1,3) ] <- c(100,200)\nnum_vec\nnum_vec[c(1,2,3)] <- 0\nnum_vec\n```\n:::\n\n\n## Importing data\n\nWe will now import a `csv` file into R, to do this we'll use the `read.csv` function. A simple template to follow is\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread.csv(file = 'path where csv is located at in your computer')\n```\n:::\n\n\nAn easy way to find the location of your data *(or any file)* is using the `file.choose()` function in R. `file.choose()` will bring up a file explorer window that allows you to interactively choose a file path to work with.\n\nIn your console, run the following command\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfile.choose()\n```\n:::\n\n\nFor example, after running the above command the `births` data set provided in class, is located in\n\n\n::: {.cell}\n\n:::\n\n\n*Note: Depending on your location and operating system the directory will be different.*\n\nTherefore, to read the `births` data set I would copy/paste the directory of the csv location and run the following command\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbirth_dat <- read.csv(file='/Users/toledo60/Desktop/Projects/personal-site/static/data/births.csv')\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbirth_dat\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n:::callout-warning\nThe above tutorial assumes the data set is a `csv` file in working condition. That is we assume the default settings for `read.csv`. In some cases we may need to change the header, specify the field separator and more. See `?read.csv` for further details and examples.\n:::\n\nWe are not just limited to `csv` files, we can import data from Excel (in `csv`, `XLSX`, or `txt` format), `SAS`, `Stata`, `SPSS`, or others. A good reference to import various data formats can be found on [datacamp r-data-import tutorial](https://www.datacamp.com/tutorial/r-data-import-tutorial)\n\n## Installing packages\n\nWhile base R contains a wide collection of useful functions and datasets, it might be necessary to install additional R packages to increase the power of R by improving existing base R functionalities, or by adding new ones.\n\nIn general, you can use this template to install a package in R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('package_name')\n```\n:::\n\n\nFor example, in this lab we will need functions/datasets from the following package: `maps`. To install we simply type in our console\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages('maps')\n```\n:::\n\n\nAfter running the above command you should get something similar to the output below. The messages appeared will depend on what operating system you are using, the dependencies, and if the package was successfully installed.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrying URL 'https://cran.rstudio.com/bin/macosx/contrib/4.2/maps_3.4.0.tgz'\nContent type 'application/x-gzip' length 3105764 bytes (3.0 MB)\n==================================================\ndownloaded 3.0 MB\n\n\nThe downloaded binary packages are in\n\t/var/folders/mc/rznpg9ks30sd6wdh7rchs4v40000gn/T//RtmpLUHvkq/downloaded_packages\n```\n:::\n\n\nOnce the package was installed successfully we now have access to all of its functionalities/datasets. To access them we load the package into memory using the command `library()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(maps)\n```\n:::\n\n\nHowever, if we only need to access say a specific function/dataset a few times we can do so using the notation `packagename::functionname()`. For example, if we only need to access the Canada cities data set in the `maps` package we run the following command\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmaps::canada.cities\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nAlternatively, if you loaded the entire package using `library(maps)` we can access the Canada cities data set using the following command\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncanada.cities\n```\n:::\n\n::: {.cell}\n\n:::\n\n\n# Overview of Births dataset\n\nFor **Section 2** and **Section 3** we consider the `births` dataset provided in class. The `births` dataset is a sample of information about babies born in North Carolina. It is considered a data frame because it contains numeric information about each baby, as well as various pieces of categorical data such as the race of the parents, and whether the mom has a smoking habit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbirth_dat <- read.csv(file='/Users/toledo60/Desktop/Projects/personal-site/static/data/births.csv')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbirth_dat\n```\n:::\n\n\nWe can view the structure of our dataset using `str()` function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(birth_dat) \n```\n:::\n\n\nWe can see there are 1992 rows and 21 columns, and the datatypes for each variable *(column)*. Those with `int` are considered numerical variables and those with `chr` are considered categorical variables.\n\n*Note:* While looking at the structure of the data using `str()` we primarily saw two types of variables: `chr` and `int` to denote character and integer data types, respectively. However we can also have `factor` and `double`.\n\n`factor` will be considered as a categorical variable and `double` would be considered as a numerical variable.\n\nWe can use the `$` operator to access values from a data frame column. For example, if we want to extract the values from the `Gender` column from our dataset, we run the following command\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbirth_dat$Gender\n```\n:::\n\n\nIf we save these values into a variable we will be able to manipulate them without altering the dataset itself.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbirths_gender <- birth_dat$Gender\n```\n:::\n\n\n# Summarizing and visualizing data (one variable)\n\nWe will use the `births` data set to summarize and visualize numerical and categorical variables using the *base R* approach\n\n## Numerical variables\n\nOne way to extract all the numerical columns is using both `Filter` and `is.numeric` functions. Below are the first five rows of all the numerical columns in `birth_dat`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFilter(is.numeric,birth_dat)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThe names of the numerical columns can be obtained using `colnames()` function in combination with the above statement\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(Filter(is.numeric,birth_dat) )\n```\n:::\n\n\nWe will only consider the `weight` variable from our dataset to demonstrate methods to summarize and visualize a numerical variable.\n\nFunctions for numerical summaries include, but not limited to,\n\n| Function    |                                    Description                                     |\n|-------------|:----------------------------------------------------------------------------------:|\n| `mean()`    |                                        mean                                        |\n| `median()`  |                                       median                                       |\n| `mode()`    |                                        mode                                        |\n| `sd()`      |                                 standard deviation                                 |\n| `var()`     |                                      variance                                      |\n| `min()`     |                                      minimum                                       |\n| `max()`     |                                      maximum                                       |\n| `summary()` | Computes the following: *Minimum ,1st Quartile, Median,Mean ,3rd Quartile,Maximum* |\n\nNext, we'll save the values from `weight` column into a separate variable and compute several numerical summaries listed above\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbirth_weight <- birth_dat$weight\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(birth_weight)\nmedian(birth_weight)\nmin(birth_weight)\nmax(birth_weight)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(birth_weight)\n```\n:::\n\n\nWhile `summary()` give us a quick numerical summary of our distribution, it is important to also visualize the overall distribution using a plot such as a boxplot\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(birth_weight)\n```\n:::\n\n\nor a histogram\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(birth_weight)\n```\n:::\n\n\nFrom the histogram above, while the overall distribution of the birth weights is symmetrical there are outliers causing the distribution to be skewed to the left. \n\nFor `boxplot()` and `hist()` we used the default settings, while they are informative we can alter their appearance to be more professional.\n\nFor example, we changed the x-axis label and y-axis label using `xlab`,`ylab` arguments,respectively. We changed the title with `main` and the color of the boxplot with `col`. The `col` argument can take values such as `red`,`blue` or any HEX code, see `?boxplot` for further customization. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(birth_weight,\n        main='Boxplot of Birth Weights',\n        xlab ='birth weights', ylab='ounces',\n        col='#61b1ed')\n```\n:::\n\n\n*Resource: For a collection of R colors by name refer to [Rcolors](http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf). Another approach is to search 'color picker' in google and copy/paste the hex code*\n\n\nWe can apply similar customization to our histogram\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(birth_weight,\n     main='Histogram of Birth Weights',\n     xlab ='birth weights',\n     col='#d1584f',\n     breaks=20)\n```\n:::\n\n\nThe `hist` function uses the Sturges method by default to determine the number of `breaks` on the histogram. We can manually change the number of breaks, but we should be careful not to specify a low or high number of breaks. Usually the default setting is appropriate for most scenarios. \n\n## Categorical variables\n\nOne way to extract all the character columns is using both `Filter` and `is.character` functions. A similar argument can be said for any columns that are factors, but instead we'd use `is.factor`. \n\nBelow are the first five rows of all the character columns in `birth_dat`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nFilter(is.character,birth_dat)\n```\n:::\n\n::: {.cell}\n\n:::\n\n\nThe names of the character columns can be obtained using `colnames()` function in combination with the above statement\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(Filter(is.character,birth_dat) )\n```\n:::\n\n\n\nWe will only consider the `Hispmom` variable from our dataset to demonstrate methods to summarize and visualize a character variable.\n\nFirst, we'll save the values from `Hispmom` column into a separate variable and compute several categorical summaries\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhispanic_mom <- birth_dat$Hispmom\n```\n:::\n\n\nThe `table()` function in R can be used to quickly create frequency tables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(hispanic_mom)\n```\n:::\n\n\nFrom the above frequency table we observe there were 25 mom who were Mexican, 1693 non Hispanic, and 84 were other types of Hispanic. We can easily convert the frequency table into a frequency table of proportions using `prop.table()`. The input for `prop.table()` is a table created using `table()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(table(hispanic_mom))\n```\n:::\n\n\nNow, we observe roughly 10.79% of moms were Mexican, 84.99% were non Hispanic and 4.22% were other types of Hispanic. Note that all of the proportions should add up to 1. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(prop.table(table(hispanic_mom)))\n```\n:::\n\n\n\nWhile the above method works, it is not the only way to obtain frequency tables. We can obtain the same results using `tally()` from the `mosaic` library.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosaic::tally(hispanic_mom)\n```\n:::\n\n\nIf we want frequency tables of proportions, we need to use the argument `format` and specify `format = 'proportion'`. There are other formats such as `'count'`, `'percent'` etc.. for more details run `?mosaicCore::tally()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmosaic::tally(hispanic_mom,format='proportion')\n```\n:::\n\n\nTo plot a single categorical variable we can use `barplot()`. The input for `barplot()` when dealing with categorical data is a `table`, like the ones we created above\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(table(hispanic_mom))\n```\n:::\n\n\nInstead of the frequency counts, we can plot frequency of proportions by inputting a frequency tables of proportions. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nbarplot(prop.table(table(hispanic_mom)),\n        main = 'Ethnicity Proportions of Moms',\n        col = '#d59cdb')\n```\n:::\n\n\n\n\n# Summarizing and visualizing data (two variables)\n\n## Numerical variables\n\nWe consider the following two numerical variables: `Feduc` and `Meduc`, which is the highest education for fathers and mothers in this dataset, respectively.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfather_eduction <- birth_dat$Feduc\nmother_education <- birth_dat$Meduc\n```\n:::\n\n\n\nWe can compare their distributions in a single plot as we did in *Section 2* with boxplots\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(father_eduction,mother_education,\n        names = c('father','mother'),\n        col=c('#f5d376','#f5767c'),\n        main = 'Highest Education for Parernts',\n        ylab = 'Year')\n```\n:::\n\n\nFor boxplots its pretty straight forward to compare two numerical distributions using the syntax `boxplot(v1,v2,...)`. For histograms it requires a bit more work.\n\nWe start by creating a histogram for the first variable, then creating another histrogam for the second variable but using the argument `add=TRUE`. We must specify a unique color for each histogram representing the variables. In order for both of the histograms to fit properly on the same plot we must take into account the lowest and highest values among the multiple numerical variables. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nlow_x <- min(father_eduction,mother_education)\nhigh_x <- max(father_eduction,mother_education)\n```\n:::\n\n\nLastly, we must specify a legend to appropriately distinguish the multiple histograms using the function `legend()`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nhist(father_eduction, col='lightcoral',\n     xlim=c(low_x,high_x),\n     main='Education for Parents', xlab='Year')\nhist(mother_education, col='lightblue', add=TRUE)\nlegend('topright', legend = c('father', 'mother'), \n       fill=c('lightcoral', 'lightblue'))\n```\n:::\n\n\n\n:::callout-warning\nWhen using `legend()` it is important that you specify the correct ordering of colors for each group, otherwise the legend would be incorrect. For example, in our first histogram we chose \"lightcoral\" to represent \"father\" and \"lightblue\" to represent \"mother\" distributions.\nWhich is why we used the arguments: \n`legend=c('father','mother'), fill = c('lightcoral','lightblue')` in that order\n:::\n\nWe can also consider a *scatter plot* to visualize the relationship between two numerical variables. We consider the two numerical variables `Gained` and `weight`. `Gained` describes the weight gained during the pregnancy term and `weight` describe the weight of the baby at birth.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(x = birth_dat$Gained,y = birth_dat$weight,\n     main = 'Baby weight vs pregnancy weight gain',\n     xlab = 'weight gained during pregnancy',\n     ylab = 'Baby weight (oz.)',\n     col='lightcoral')\n```\n:::\n\n\n\n## Categorical variables\n\nFor this example, we consider the following two character variables `Hispdad` and `Habit`. `Hispdad` determines whether the father of the baby was Hispanic or not. In particular, are they Mexican, non-Hispanic, or other type of Hispanic ethnicity. `Habit` determines whether or not the subject had a smoking habit or not.\n\nWhen dealing with two categorical variables we can create a two-way table using `table(v1,v2)`. Below is the table of frequency for both `Habit` and `Hispdad`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntable(birth_dat$Habit,birth_dat$Hispdad)\n```\n:::\n\n\nFrom the above frequency table of counts you will notice that there were 184 Mexican dads who were non-smokers, 5 Mexican dads who were smokers, 12346 non-Hispanics who were non-smokers, 117 non-Hispanics who were smokers and similar interpretations can be made for the remaining cells.\n\nWe can obtain a frequency table of proportions using `prop.table()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprop.table(table(birth_dat$Habit,birth_dat$Hispdad))\n```\n:::\n\n\nYou will notice that summing each cell will give us 1\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(prop.table(table(birth_dat$Habit,birth_dat$Hispdad)))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}