---
author: Jose Toledo Luna
date: 2023-10-13
title: Lab 2 
toc: true
comments: false
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  comment = "#>",
  fig.width = 6,
  fig.height = 4,
  eval = TRUE
)
```

---


In this lab we will learn about logical statements and their applications such as subsetting 

- [Logical Statements and Applications](/ucla/stats10/labs/lab2.qmd)


## For Loops 

### Using a For-Loop on a vector

A for-loop serves the purpose of cycling through a collection of objects, such as a vector, list, matrix, or dataframe, and consistently applying a specific set of operations to each element within the data structure.

Utilizing for-loops helps maintain code cleanliness and prevents unnecessary duplication of code blocks.

```{r,eval=FALSE}
for(index in indexing_set) {
  code block
}
```

To start with a very simple example, consider printing the numbers from 1 to 6 inclusive


```{r}
for (index in 1:6){
  print(index)
}
```


`index` can be any variable name, usually in the context of the problem. For example, this can be anything from `car`,`letters`, `months`, etc.., in most cases usually the variable name `i` suffices. Our `code block` or expression is simply to `print()` the current index


```{r}
for(i in 1:6){
  print(i*2)
}
```

In this scenario, we begin by printing the numbers from `1 to 6` and then doubling each number before printing it. You can see this in the line of code: `print(i * 2)`. 

However, there are scenarios where we not only want to print these values but also store them after each iteration. To do that, we need to start by creating an empty object. This object can be new or an existing one, but it's important to keep in mind that after each iteration, the object may be modified


The function `numeric()` creates a numeric vector of all `0` of a specified `length`. Here the `length`, should be the the same size as the `indexing_set`

```{r}
vec <- numeric(length = 5)
```

```{r}
vec
```


```{r}
for(i in 1:5){
  print(paste0('Current Iteration: ',i) ) #<1>
  
  vec[i] <- (i*2)  #<2>
  
  print(vec) #<3>
}
```
1. Print the current iteration *(optional)*
2. Update the $i$th element of the vector `vec` by doubling the current index
3. Print the updated vector `vec` *(optional)*


Here is the resulting vector

```{r}
vec
```

:::callout-warning
In R, for-loops tend to be slow. To mitigate the performance issues associated with for-loops, it is often recommended to use vectorized operations or apply functions
:::


For example, 

```{r}
vec <- 2*(1:5)
vec
```

In this example, there was no need to use a for-loop. It was simply for teaching purposes

We don't need to iterate sequentially from a regular sequence `1:N`, as in the previous example. We can iterate through the elements of an existing object. For example,

```{r}
for(index in c(2,3,4)){
  print(index)
}
```


```{r}
for(pet in c('dog','cat','hamster','turtle')){
  print(pet)
}
```


However, if you are trying to update the $i$th element of an object this approach might not be the best

```{r}
vec3 <- numeric(3)
vec3

for(index in c(2,4,6) ){
  print( vec3[index] )
}
```

An `NA` is produced because our vector `v3` has three elements and we are trying to access the 4th and 6th element which do not exist. Instead use the function `seq_along(x)` which will create a regular sequence from `1:length(x)`

```{r}
seq_along(c(2,4,6))
```

```{r}
seq_along(c('dog','cat','hamster','turtle'))
```


```{r}
for(index in seq_along(c(2,4,6)) ){
  print(index)
}
```






