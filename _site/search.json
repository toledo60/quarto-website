[
  {
    "objectID": "teaching.html",
    "href": "teaching.html",
    "title": "Jose Toledo Luna",
    "section": "",
    "text": "UCLA STATS 10: Introduction to Statistical Reasoning (Winter 2023)"
  },
  {
    "objectID": "teaching.html#previous-courses",
    "href": "teaching.html#previous-courses",
    "title": "Jose Toledo Luna",
    "section": "Previous Courses",
    "text": "Previous Courses\n\nUniversity of California, Los Angeles\n\nSTATS 10: Introduction to Statistical Reasoning (Fall 2022)\nSTATS 13: Introduction to Statistical Methods for Life\nand Health Sciences (Summer 2022)\n\n\n\nCalifornia State University, Fullerton\n\nMath 115: College Algebra (Fall 2019)\nMath 120: Elementary Statistics (Spring 2020, Fall 2020)\nMath 338: Statistics Applied to Natural Sciences (Spring 2021)"
  },
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "Jose Toledo Luna",
    "section": "",
    "text": "Luna, J. , Jaynes, J. , Xu, H. , Wong, WK. Orthogonal array composite designs for drug combination experiments with applications for tuberculosis. Statistics in Medicine. 2022; 1- 18"
  },
  {
    "objectID": "research.html#software",
    "href": "research.html#software",
    "title": "Jose Toledo Luna",
    "section": "Software",
    "text": "Software\n\nggDoE: Create commonly used graphs in Design of Experiments with ggplot2\npyLHD: Latin Hypercube Designs for Python"
  },
  {
    "objectID": "zoom.html",
    "href": "zoom.html",
    "title": "Jose Toledo Luna",
    "section": "",
    "text": "Date\nLink\n\n\n\n\nMonday (01/09)\nLecture 1\n\n\nWednesday (01/11)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jose Toledo Luna",
    "section": "",
    "text": "I am currently a second year Statistics Ph.D. student at University of California, Los Angeles (UCLA) working with Hongquan Xu. Prior to joining UCLA, I obtained my BA and MS degrees in Statistics from California State University, Fullerton. You can learn more about me from my CV\nI am gratefully funded by the Eugene V. Cota-Robles Fellowship\nEmail: toledo60@g.ucla.edu"
  },
  {
    "objectID": "ucla/stats10/intro.html",
    "href": "ucla/stats10/intro.html",
    "title": "Welcome To STATS10",
    "section": "",
    "text": "Important\n\n\n\nUseful Links\n\nZoom For online discussion and/or virtual office hours\nBox Folder All material for the labs will be posted here\ncampuswire Have discussions or ask questions regarding this course\ngradescope Submit homework and lab assignments (PDF only)\n\n\n\nDiscussions:  4A M/W: 12:00pm-12:50pm (Online)  4B M/W: 1:00pm-1:50pm (PAB 1749)\nOffice Hours:  M/W: 12:00pm-12:50pm  @MS8349 or Zoom\nEmail: toledo60@g.ucla.edu\n\nLecture Recordings\n\nMaterial from this course can be downloaded from this Box Folder\nFor general questions or specific questions about the labs use campuswire. Otherwise, you can email me personally. The class code to join campuswire is posted on CANVAS\nAll lab assignments are to be turned in through gradescope\nBelow are all the labs regrading this course. In labs, you will apply the concepts discussed in lectures but with a focus on computation. All labs will be completed using R and documented with R markdown.\n\n\n\n\n\n\nWarning\n\n\n\nLab tutorials are a work in progress and are constantly being updated\n\n\n\nLab 1: Introduction to R"
  },
  {
    "objectID": "ucla/stats10/lab1.html",
    "href": "ucla/stats10/lab1.html",
    "title": "Jose Toledo Luna",
    "section": "",
    "text": "This lab consists of learning fundamental concepts in R\n\n\nA variable provides us with named objects that our programs can manipulate. A valid variable name consists of letters, numbers and the dot or underline characters. It is important to note variable names are case sensitive. That is, var1 and Var1 are different variables. Below are appropriate variable names in R\n\n\n\n\n\n\n\nValid Variable Name\nReason\n\n\n\n\nvariable_name\nContains letters and underscore\n\n\nlong.variable_name\nContains letters, dot, and underscore\n\n\nvar\nContains letters\n\n\nvar1\nContains letters and numbers\n\n\nlong.variable_name2\nContains letters, numbers, dot and underscore\n\n\nvar1_name.1\nContains letters, numbers, dot and underscore\n\n\n.var_name\nCan start with period, contains letters and underscore\n\n\n\nThis is a good starting point for valid variable names. Next we demonstrate a few examples where variable names are invalid.\n\n\n\n\n\n\n\nInvalid Variable Names\nReason\n\n\n\n\n2var\nStarts with a number\n\n\n_varname\nStarts with underscore\n\n\n.2var_name\nWhile starting with a (.) dot is valid, it can not be followed by a number\n\n\n\nNow that we have an idea of how to name variables, lets discuss variable assignments. Variables can be assigned values using leftward (<-), rightward (->) and equal (=) operators. However, we will only stick with the leftward and equal assignment operators.\n\nvar_name1 <- 10\nvar2 = 20\nvar.name3 <- 30\nvar_name_4 = 40\n\n\n\n\nThe easiest method to create any type of vector in R is using c() (as in concatenate). We primarily focus on two types of vectors; numeric and character\n\n\n\nnum_vec <- c(0,1,2,3,4)\ntypeof(num_vec)\n\n#> [1] \"double\"\n\nclass(num_vec)\n\n#> [1] \"numeric\"\n\n\nUsing c() is not the only way to generate a vector, we can also generate the above vector using seq() as follows\n\nseq(from=0,to=4)\n\n#> [1] 0 1 2 3 4\n\n\nAnother approach to generate the same sequence can be done using 0:4\n\n0:4\n\n#> [1] 0 1 2 3 4\n\n\nor more generally a:b, where a is the starting number and b is the last number in the sequence\nWe can apply arithmetic operations to our numerical vector num_vec, such as addition, subtraction, multiplication, division, and exponentiation. These operations will be applied to each element in the vector (element-wise).\n\n\n\nOperator\nDescription\n\n\n\n\n+\nAddition\n\n\n-\nSubtraction\n\n\n*\nMultiplication\n\n\n/\nDivision\n\n\n^\nExponent\n\n\n%%\nModulus (Remainder from division)\n\n\n%/%\nInteger Division\n\n\n\nArithmetic operations applied to numeric vectors follow PEMDAS order of operations, demonstrated in the following example\nSubtract 1 from each element\n\n(num_vec-1)\n\n#> [1] -1  0  1  2  3\n\n\nSubtract 1 from each element, then square them\n\n(num_vec-1)^2\n\n#> [1] 1 0 1 4 9\n\n\nSubtract 1 from each element, square them, then double each element\n\n 2*(num_vec - 1)^2\n\n#> [1]  2  0  2  8 18\n\n\nSubtract 1 from each element, square them, double them, then add 1 to each element\n\n2*(num_vec - 1)^2 + 1\n\n#> [1]  3  1  3  9 19\n\n\n\npemdas_vec <- 2*(num_vec - 1)^2 + 1\npemdas_vec\n\n#> [1]  3  1  3  9 19\n\n\nGenerating an odd sequence from 1 to 9, we can use c() or seq()\n\nc(1,3,5,7,9)\n\n#> [1] 1 3 5 7 9\n\nseq(from =1,to=10,by=2)\n\n#> [1] 1 3 5 7 9\n\n\nNote if you know the ordering of the arguments of a function it is not necessary to specify them. For example, it is optional to write from and to arguments in the seq() function\n\nseq(from = 1,to = 10)\n\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(1,10)\n\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\n\n\n\n\n\nchr_vec <- c('A','B',\"C\")\ntypeof(chr_vec)\n\n#> [1] \"character\"\n\nclass(chr_vec)\n\n#> [1] \"character\"\n\n\n\n\n\n\nThere are multiple ways to access or replace values in vectors. The most common approach is through “indexing”. It is important to know in starts with index 1.\n\nbig_vec <- 1:100\nbig_vec[1]\n\n#> [1] 1\n\nbig_vec[10] # extract the 10th element in your vector\n\n#> [1] 10\n\n\nFor accessing elements in a vector we can think vector[indices you want to extract] the way we extract certain elements can be through some condition, that is vector[condtion]\n\nbig_vec[ c(1,5,10) ]\n\n#> [1]  1  5 10\n\nbig_vec[ 1:10 ] # what are the first 10 elements ?\n\n#>  [1]  1  2  3  4  5  6  7  8  9 10\n\n\nUsing c() we can concatenate elements from one vector into another vector. For example, we can add the elements from pemdas_vec into the existing vector num_vec\n\nc(num_vec,pemdas_vec)\n\n#>  [1]  0  1  2  3  4  3  1  3  9 19\n\n\nAlternatively, we can add the elements from num_vec into the existing vector pemdas_vec\n\nc(pemdas_vec,num_vec)\n\n#>  [1]  3  1  3  9 19  0  1  2  3  4\n\n\nYou will notice the order in which we concatenate the elements from the vectors does matter\n\nchr_vec\n\n#> [1] \"A\" \"B\" \"C\"\n\nchr_vec[1] <- 'a'\nchr_vec\n\n#> [1] \"a\" \"B\" \"C\"\n\n\n\nnum_vec\n\n#> [1] 0 1 2 3 4\n\nnum_vec[3] <- 10\nnum_vec\n\n#> [1]  0  1 10  3  4\n\nnum_vec[ c(1,3) ] <- c(100,200)\nnum_vec\n\n#> [1] 100   1 200   3   4\n\nnum_vec[c(1,2,3)] <- 0\nnum_vec\n\n#> [1] 0 0 0 3 4\n\n\n\n\n\nWhile base R contains a wide collection of useful functions and datasets, it might be necessary to install additional R packages to increase the power of R by improving existing base R functionalities, or by adding new ones.\nIn general, you can use this template to install a package in R:\n\ninstall.packages('package_name')\n\nFor example, in this lab we will need functions/datasets from the following package: maps. To install we simply type in our console\n\ninstall.packages('maps')\n\nAfter running the above command you should get something similar to the output below. The messages appeared will depend on what operating system you are using, the dependencies, and if the package was successfully installed.\n\ntrying URL 'https://cran.rstudio.com/bin/macosx/contrib/4.2/maps_3.4.0.tgz'\nContent type 'application/x-gzip' length 3105764 bytes (3.0 MB)\n==================================================\ndownloaded 3.0 MB\n\n\nThe downloaded binary packages are in\n    /var/folders/mc/rznpg9ks30sd6wdh7rchs4v40000gn/T//RtmpLUHvkq/downloaded_packages\n\nOnce the package was installed successfully we now have access to all of its functionalities/datasets. To access them we load the package into memory using the command library()\n\nlibrary(maps)\n\nHowever, if we only need to access say a specific function/dataset a few times we can do so using the notation packagename::functionname(). For example, if we only need to access the Canada cities data set in the maps package we run the following command\n\nmaps::canada.cities\n\n\n\n#>            name country.etc    pop   lat    long capital\n#> 1 Abbotsford BC          BC 157795 49.06 -122.30       0\n#> 2      Acton ON          ON   8308 43.63  -80.03       0\n#> 3 Acton Vale QC          QC   5153 45.63  -72.57       0\n#> 4    Airdrie AB          AB  25863 51.30 -114.02       0\n#> 5    Aklavik NT          NT    643 68.22 -135.00       0\n\n\nAlternatively, if you loaded the entire package using library(maps) we can access the Canada cities data set using the following command\n\ncanada.cities\n\n\n\n#>            name country.etc    pop   lat    long capital\n#> 1 Abbotsford BC          BC 157795 49.06 -122.30       0\n#> 2      Acton ON          ON   8308 43.63  -80.03       0\n#> 3 Acton Vale QC          QC   5153 45.63  -72.57       0\n#> 4    Airdrie AB          AB  25863 51.30 -114.02       0\n#> 5    Aklavik NT          NT    643 68.22 -135.00       0"
  },
  {
    "objectID": "ucla/stats10/lab1.html#overview-of-births-dataset",
    "href": "ucla/stats10/lab1.html#overview-of-births-dataset",
    "title": "Jose Toledo Luna",
    "section": "Overview of Births Dataset",
    "text": "Overview of Births Dataset\nThe births dataset is a sample of information about babies born in North Carolina. It is considered a data frame because it contains numeric information about each baby, as well as various pieces of categorical data such as the race of the parents, and whether the parents had a smoking habit.\n\nbirth_dat <- read.csv(file=\"/Users/toledo60/Desktop/Projects/personal-website/ucla/stats10/data/births.csv\")\n\n\nbirth_dat\n\n\n\n#>   Gender Premie weight Apgar1 Fage Mage Feduc Meduc TotPreg Visits   Marital\n#> 1   Male     No    124      8   31   25    13    14       1     13   Married\n#> 2 Female     No    177      8   36   26     9    12       2     11 Unmarried\n#> 3   Male     No    107      3   30   16    12     8       2     10 Unmarried\n#> 4 Female     No    144      6   33   37    12    14       2     12 Unmarried\n#> 5   Male     No    117      9   36   33    10    16       2     19   Married\n#>   Racemom Racedad Hispmom Hispdad Gained     Habit MomPriorCond BirthDef\n#> 1   White   White NotHisp NotHisp     40 NonSmoker         None     None\n#> 2   White   White Mexican Mexican     20 NonSmoker         None     None\n#> 3   White Unknown Mexican Unknown     70 NonSmoker At Least One     None\n#> 4   White   White NotHisp NotHisp     50 NonSmoker         None     None\n#> 5   White   Black NotHisp NotHisp     40 NonSmoker At Least One     None\n#>      DelivComp BirthComp\n#> 1 At Least One      None\n#> 2 At Least One      None\n#> 3 At Least One      None\n#> 4 At Least One      None\n#> 5         None      None\n\n\nWe can view the structure of our dataset using str() function\n\nstr(birth_dat) \n\n#> 'data.frame':    1992 obs. of  21 variables:\n#>  $ Gender      : chr  \"Male\" \"Female\" \"Male\" \"Female\" ...\n#>  $ Premie      : chr  \"No\" \"No\" \"No\" \"No\" ...\n#>  $ weight      : int  124 177 107 144 117 98 147 138 104 123 ...\n#>  $ Apgar1      : int  8 8 3 6 9 4 8 9 9 9 ...\n#>  $ Fage        : int  31 36 30 33 36 31 33 22 30 23 ...\n#>  $ Mage        : int  25 26 16 37 33 29 30 20 21 18 ...\n#>  $ Feduc       : int  13 9 12 12 10 14 12 14 12 12 ...\n#>  $ Meduc       : int  14 12 8 14 16 16 9 14 12 12 ...\n#>  $ TotPreg     : int  1 2 2 2 2 3 4 1 1 1 ...\n#>  $ Visits      : int  13 11 10 12 19 20 16 10 30 16 ...\n#>  $ Marital     : chr  \"Married\" \"Unmarried\" \"Unmarried\" \"Unmarried\" ...\n#>  $ Racemom     : chr  \"White\" \"White\" \"White\" \"White\" ...\n#>  $ Racedad     : chr  \"White\" \"White\" \"Unknown\" \"White\" ...\n#>  $ Hispmom     : chr  \"NotHisp\" \"Mexican\" \"Mexican\" \"NotHisp\" ...\n#>  $ Hispdad     : chr  \"NotHisp\" \"Mexican\" \"Unknown\" \"NotHisp\" ...\n#>  $ Gained      : int  40 20 70 50 40 21 22 20 11 19 ...\n#>  $ Habit       : chr  \"NonSmoker\" \"NonSmoker\" \"NonSmoker\" \"NonSmoker\" ...\n#>  $ MomPriorCond: chr  \"None\" \"None\" \"At Least One\" \"None\" ...\n#>  $ BirthDef    : chr  \"None\" \"None\" \"None\" \"None\" ...\n#>  $ DelivComp   : chr  \"At Least One\" \"At Least One\" \"At Least One\" \"At Least One\" ...\n#>  $ BirthComp   : chr  \"None\" \"None\" \"None\" \"None\" ...\n\n\nThere are 1992 rows and 21 columns, and we can see the datatypes for each variable (column). Those with int are considered numerical variables and those with chr are considered categorical variables.\nNote: While looking at the structure of the data using str() we primarily saw two types of variables: chr and int to denote character and integer data types, respectively. However we can also have factor and double.\nfactor will be considered as a categorical variable and double would be considered as a numerical variable.\nWe can use the $ operator to access values from a data frame column. For example, if we want to extract the values from the Gender column from our dataset, we run the following command\n\nbirth_dat$Gender\n\n\n\n#> [1] \"Male\"   \"Female\" \"Male\"   \"Female\" \"Male\"   \"Female\" \"Male\"   \"Male\"\n\n\nIf we save these values into a variable we will be able to manipulate them without altering the dataset itself.\n\ngenders <- birth_dat$Gender"
  },
  {
    "objectID": "ucla/stats10/lab1.html#single-variable",
    "href": "ucla/stats10/lab1.html#single-variable",
    "title": "Jose Toledo Luna",
    "section": "Single variable",
    "text": "Single variable\n\nNumerical variables\nOne way to extract all the numerical columns is using both Filter and is.numeric functions. Below are the first five rows of all the numerical columns in birth_dat\n\nFilter(is.numeric,birth_dat)\n\n\n\n#>   weight Apgar1 Fage Mage Feduc Meduc TotPreg Visits Gained\n#> 1    124      8   31   25    13    14       1     13     40\n#> 2    177      8   36   26     9    12       2     11     20\n#> 3    107      3   30   16    12     8       2     10     70\n#> 4    144      6   33   37    12    14       2     12     50\n#> 5    117      9   36   33    10    16       2     19     40\n\n\nThe names of the numerical columns can be obtained using colnames() function in combination with the above statement\n\ncolnames(Filter(is.numeric,birth_dat) )\n\n#> [1] \"weight\"  \"Apgar1\"  \"Fage\"    \"Mage\"    \"Feduc\"   \"Meduc\"   \"TotPreg\"\n#> [8] \"Visits\"  \"Gained\"\n\n\nWe will only consider the weight variable from our dataset to demonstrate methods to summarize and visualize a numerical variable.\nFunctions for numerical summaries include, but not limited to,\n\n\n\n\n\n\n\nFunction\nDescription\n\n\n\n\nmean()\nmean\n\n\nmedian()\nmedian\n\n\nmode()\nmode\n\n\nsd()\nstandard deviation\n\n\nvar()\nvariance\n\n\nmin()\nminimum\n\n\nmax()\nmaximum\n\n\nsummary()\nComputes the following: Minimum ,1st Quartile, Median,Mean ,3rd Quartile,Maximum\n\n\n\nNext, we’ll save the values from weight column into a separate variable and compute several numerical summaries listed above\n\nbirth_weight <- birth_dat$weight\n\n\nmean(birth_weight)\n\n#> [1] 116.0512\n\nmedian(birth_weight)\n\n#> [1] 117\n\nmin(birth_weight)\n\n#> [1] 14\n\nmax(birth_weight)\n\n#> [1] 177\n\n\n\nsummary(birth_weight)\n\n#>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n#>    14.0   106.0   117.0   116.1   129.0   177.0\n\n\nWhile summary() give us a quick numerical summary of our distribution, it is important to also visualize the overall distribution using a plot such as a boxplot\n\nboxplot(birth_weight)\n\n\n\n\nor a histogram\n\nhist(birth_weight)\n\n\n\n\nFrom the histogram above, while the overall distribution of the birth weights is symmetrical there are outliers causing the distribution to be skewed to the left.\nFor boxplot() and hist() we used the default settings, while they are informative we can alter their appearance to be more professional.\nFor example, we changed the x-axis label and y-axis label using xlab,ylab arguments,respectively. We changed the title with main and the color of the boxplot with col. The col argument can take values such as red,blue or any HEX code, see ?boxplot for further customization.\n\nboxplot(birth_weight,\n        main='Boxplot of Birth Weights',\n        xlab ='birth weights', ylab='ounces',\n        col='#61b1ed')\n\n\n\n\nResource: For a collection of R colors by name refer to Rcolors. Another approach is to search ‘color picker’ in google and copy/paste the hex code\nWe can apply similar customization to our histogram\n\nhist(birth_weight,\n     main='Histogram of Birth Weights',\n     xlab ='birth weights',\n     col='#d1584f',\n     breaks=20)\n\n\n\n\nThe hist function uses the Sturges method by default to determine the number of breaks on the histogram. We can manually change the number of breaks, but we should be careful not to specify a low or high number of breaks. Usually the default setting is appropriate for most scenarios.\n\n\nCategorical variables\nOne way to extract all the character columns is using both Filter and is.character functions. A similar argument can be said for any columns that are factors, but instead we’d use is.factor.\nBelow are the first five rows of all the character columns in birth_dat\n\nFilter(is.character,birth_dat)\n\n\n\n#>   Gender Premie   Marital Racemom Racedad Hispmom Hispdad     Habit\n#> 1   Male     No   Married   White   White NotHisp NotHisp NonSmoker\n#> 2 Female     No Unmarried   White   White Mexican Mexican NonSmoker\n#> 3   Male     No Unmarried   White Unknown Mexican Unknown NonSmoker\n#> 4 Female     No Unmarried   White   White NotHisp NotHisp NonSmoker\n#> 5   Male     No   Married   White   Black NotHisp NotHisp NonSmoker\n#>   MomPriorCond BirthDef    DelivComp BirthComp\n#> 1         None     None At Least One      None\n#> 2         None     None At Least One      None\n#> 3 At Least One     None At Least One      None\n#> 4         None     None At Least One      None\n#> 5 At Least One     None         None      None\n\n\nThe names of the character columns can be obtained using colnames() function in combination with the above statement\n\ncolnames(Filter(is.character,birth_dat) )\n\n#>  [1] \"Gender\"       \"Premie\"       \"Marital\"      \"Racemom\"      \"Racedad\"     \n#>  [6] \"Hispmom\"      \"Hispdad\"      \"Habit\"        \"MomPriorCond\" \"BirthDef\"    \n#> [11] \"DelivComp\"    \"BirthComp\"\n\n\nWe will only consider the Hispmom variable from our dataset to demonstrate methods to summarize and visualize a character variable.\nFirst, we’ll save the values from Hispmom column into a separate variable and compute several categorical summaries\n\nhispanic_mom <- birth_dat$Hispmom\n\nThe table() function in R can be used to quickly create frequency tables.\n\ntable(hispanic_mom)\n\n#> hispanic_mom\n#>   Mexican   NotHisp OtherHisp \n#>       215      1693        84\n\n\nFrom the above frequency table we observe there were 25 mom who were Mexican, 1693 non Hispanic, and 84 were other types of Hispanic. We can easily convert the frequency table into a frequency table of proportions using prop.table(). The input for prop.table() is a table created using table().\n\nprop.table(table(hispanic_mom))\n\n#> hispanic_mom\n#>    Mexican    NotHisp  OtherHisp \n#> 0.10793173 0.84989960 0.04216867\n\n\nNow, we observe roughly 10.79% of moms were Mexican, 84.99% were non Hispanic and 4.22% were other types of Hispanic. Note that all of the proportions should add up to 1.\n\nsum(prop.table(table(hispanic_mom)))\n\n#> [1] 1\n\n\nWhile the above method works, it is not the only way to obtain frequency tables. We can obtain the same results using tally() from the mosaic library.\n\nmosaic::tally(hispanic_mom)\n\n#> X\n#>   Mexican   NotHisp OtherHisp \n#>       215      1693        84\n\n\nIf we want frequency tables of proportions, we need to use the argument format and specify format = 'proportion'. There are other formats such as 'count', 'percent' etc.. for more details run ?mosaicCore::tally()\n\nmosaic::tally(hispanic_mom,format='proportion')\n\n#> X\n#>    Mexican    NotHisp  OtherHisp \n#> 0.10793173 0.84989960 0.04216867\n\n\nTo plot a single categorical variable we can use barplot(). The input for barplot() when dealing with categorical data is a table, like the ones we created above\n\nbarplot(table(hispanic_mom))\n\n\n\n\nInstead of the frequency counts, we can plot frequency of proportions by inputting a frequency tables of proportions.\n\nbarplot(prop.table(table(hispanic_mom)),\n        main = 'Ethnicity Proportions of Moms',\n        col = '#d59cdb')"
  },
  {
    "objectID": "ucla/stats10/lab1.html#two-variables",
    "href": "ucla/stats10/lab1.html#two-variables",
    "title": "Jose Toledo Luna",
    "section": "Two variables",
    "text": "Two variables\n\nNumerical variables\nWe consider the following two numerical variables: Feduc and Meduc, which is the highest education for fathers and mothers in this dataset, respectively.\n\nfather_eduction <- birth_dat$Feduc\nmother_education <- birth_dat$Meduc\n\nWe can compare their distributions in a single plot as we did in Section 2 with boxplots\n\nboxplot(father_eduction,mother_education,\n        names = c('father','mother'),\n        col=c('#f5d376','#f5767c'),\n        main = 'Highest Education for Parernts',\n        ylab = 'Year')\n\n\n\n\nFor boxplots its pretty straight forward to compare two numerical distributions using the syntax boxplot(v1,v2,...). For histograms it requires a bit more work.\nWe start by creating a histogram for the first variable, then creating another histrogam for the second variable but using the argument add=TRUE. We must specify a unique color for each histogram representing the variables. In order for both of the histograms to fit properly on the same plot we must take into account the lowest and highest values among the multiple numerical variables.\n\nlow_x <- min(father_eduction,mother_education)\nhigh_x <- max(father_eduction,mother_education)\n\nLastly, we must specify a legend to appropriately distinguish the multiple histograms using the function legend().\n\nhist(father_eduction, col='lightcoral',\n     xlim=c(low_x,high_x),\n     main='Education for Parents', xlab='Year')\nhist(mother_education, col='lightblue', add=TRUE)\nlegend('topright', legend = c('father', 'mother'), \n       fill=c('lightcoral', 'lightblue'))\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nWhen using legend() it is important that you specify the correct ordering of colors for each group, otherwise the legend would be incorrect. For example, in our first histogram we chose “lightcoral” to represent “father” and “lightblue” to represent “mother” distributions. Which is why we used the arguments: legend=c('father','mother'), fill = c('lightcoral','lightblue') in that order\n\n\nWe can also consider a scatter plot to visualize the relationship between two numerical variables. We consider the two numerical variables Gained and weight. Gained describes the weight gained during the pregnancy term and weight describe the weight of the baby at birth.\n\nplot(x = birth_dat$Gained,y = birth_dat$weight,\n     main = 'Baby weight vs pregnancy weight gain',\n     xlab = 'weight gained during pregnancy',\n     ylab = 'Baby weight (oz.)',\n     col='lightcoral')\n\n\n\n\n\n\nCategorical variables\nFor this example, we consider the following two character variables Hispdad and Habit. Hispdad determines whether the father of the baby was Hispanic or not. In particular, are they Mexican, non-Hispanic, or other type of Hispanic ethnicity. Habit determines whether or not the subject had a smoking habit or not.\nWhen dealing with two categorical variables we can create a two-way table using table(v1,v2). Below is the table of frequency for both Habit and Hispdad.\n\ntable(birth_dat$Habit,birth_dat$Hispdad)\n\n#>            \n#>             Mexican NotHisp OtherHisp Unknown\n#>   NonSmoker     184    1236        78     307\n#>   Smoker          5     117         2      63\n\n\nFrom the above frequency table of counts you will notice that there were 184 Mexican dads who were non-smokers, 5 Mexican dads who were smokers, 12346 non-Hispanics who were non-smokers, 117 non-Hispanics who were smokers and similar interpretations can be made for the remaining cells.\nWe can obtain a frequency table of proportions using prop.table()\n\nprop.table(table(birth_dat$Habit,birth_dat$Hispdad))\n\n#>            \n#>                 Mexican     NotHisp   OtherHisp     Unknown\n#>   NonSmoker 0.092369478 0.620481928 0.039156627 0.154116466\n#>   Smoker    0.002510040 0.058734940 0.001004016 0.031626506\n\n\nYou will notice that summing each cell will give us 1\n\nsum(prop.table(table(birth_dat$Habit,birth_dat$Hispdad)))\n\n#> [1] 1"
  }
]